package gred.nucleus.autocrop;

import fr.igred.omero.Client;
import fr.igred.omero.exception.AccessException;
import fr.igred.omero.exception.ServiceException;
import fr.igred.omero.repository.DatasetWrapper;
import fr.igred.omero.repository.ProjectWrapper;
import gred.nucleus.files.Directory;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.TextRoi;
import ij.io.FileSaver;
import ij.plugin.ContrastEnhancer;
import ij.plugin.ZProjector;
import ij.process.ImageConverter;
import ij.process.ImageProcessor;
import loci.formats.FormatException;
import loci.plugins.BF;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.regex.Pattern;


/**
 * This class creates Z projection file of 3D stack (wide field image) and report boxes for each nucleus cropped by the
 * Autocrop class.
 * <p> It takes the raw images input crop and the list of boxes coordinates generated by the Autocrop class.
 *
 * @author Tristan Dubos and Axel Poulet
 */
public class AnnotateAutoCrop {
	/** Logger */
	private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	
	/** List of the coordinate boxes of cropped nucleus */
	private final List<String>       boxCoordinates;
	/** the path of the directory where image with boxes is saved */
	private final String             outputDirPath;
	/** Parameters crop analyse */
	private final AutocropParameters autocropParameters;
	/** ImagePlus of the Z projection */
	private ImagePlus zProjection;
	/** The prefix of the names of the output cropped images, which are automatically numbered */
	private String    outputFilesPrefix;
	
	
	/**
	 * Constructor for autocrop
	 *
	 * @param boxesCoordinates   List of coordinates (coordinates of nuclei cropped)
	 * @param imageFile          File of current image analysed
	 * @param outputDirPath      Path to the output folder
	 * @param autocropParameters Autocrop parameters used to crop nuclei
	 * @param prefix             Name of raw image (use for z projection)
	 *
	 * @throws IOException     if imageFile cannot be opened
	 * @throws FormatException if something goes wrong performing a file format operation
	 */
	public AnnotateAutoCrop(List<String> boxesCoordinates,
	                        File imageFile,
	                        String outputDirPath,
	                        String prefix,
	                        AutocropParameters autocropParameters)
	throws IOException, FormatException {
		this(boxesCoordinates, imageFile, outputDirPath, autocropParameters);
		this.outputFilesPrefix = prefix;
		Directory dirOutput = new Directory(this.outputDirPath + "zprojection");
		dirOutput.checkAndCreateDir();
	}
	
	
	/**
	 * Constructor for re-generate projection after segmentation
	 *
	 * @param boxesCoordinates   List of coordinates (coordinates of nuclei cropped)
	 * @param imageFile          File of current image analysed
	 * @param outputDirPath      Path to the output folder
	 * @param autocropParameters Autocrop parameters used to crop nuclei
	 *
	 * @throws IOException     If imageFile cannot be opened
	 * @throws FormatException If something goes wrong performing a file format operation
	 */
	public AnnotateAutoCrop(List<String> boxesCoordinates,
	                        File imageFile,
	                        String outputDirPath,
	                        AutocropParameters autocropParameters)
	throws IOException, FormatException {
		this.autocropParameters = autocropParameters;
		this.zProjection =
				BF.openImagePlus(imageFile.getAbsolutePath())[this.autocropParameters.getSlicesOTSUComputing()];
		this.boxCoordinates = boxesCoordinates;
		this.outputDirPath = outputDirPath;
	}


	public AnnotateAutoCrop(List<String> boxesCoordinates,
							ImagePlus imp,
							String outputDirPath,
							String prefix,
							AutocropParameters autocropParameters) {
		this.autocropParameters = autocropParameters;
		this.zProjection = imp;
		this.boxCoordinates = boxesCoordinates;
		this.outputDirPath = outputDirPath;
		this.outputFilesPrefix = prefix ;
		Directory dirOutput = new Directory(this.outputDirPath + "zprojection");
		dirOutput.checkAndCreateDir();
	}

	/**
	 * Main method to generate Z projection of wide field 3D image. Parameter use are max intensity projection
	 * (projectionMax method) and contrast modification of 0,3.
	 */
	public void runAddBadCrop() {
		ContrastEnhancer enh = new ContrastEnhancer();
		enh.stretchHistogram(this.zProjection, 0.35);
		ImageConverter converter = new ImageConverter(this.zProjection);
		converter.convertToRGB();
		
		for (String boxCoordinate : this.boxCoordinates) {
			String[] splitLine = boxCoordinate.split("\\t");
			String[] fileName  = splitLine[0].split(Pattern.quote(File.separator));
			String[] name      = fileName[fileName.length - 1].split("_");
			LOGGER.trace("Bad crop number {} saved to file: {}",
			             Integer.parseInt(name[name.length - 2]),
			             splitLine[0]);
			addBoxCropToZProjection(boxCoordinate, Integer.parseInt(name[name.length - 2]), Color.RED);
		}
		String outFileZBox = this.outputDirPath + "_BAD_CROP_LESS.tif";
		LOGGER.debug("badCrop outFileZBox: {}", outFileZBox);
		saveFile(this.zProjection, outFileZBox);
	}
	
	
	/**
	 * Main method to generate Z projection of wide field 3D image. Parameter use are max intensity projection
	 * (projectionMax method) and contrast modification of 0,3.
	 */
	public void run() {
		LOGGER.info("Z projection annotation.");
		ZProjector zProjectionTmp = new ZProjector(this.zProjection);
		this.zProjection = projectionMax(zProjectionTmp);
		adjustContrast(0.3);
		ImageConverter converter = new ImageConverter(this.zProjection);
		converter.convertToRGB();
		
		for (String boxCoordinate : this.boxCoordinates) {
			String[] splitLine = boxCoordinate.split("\\t");
			String[] fileName  = splitLine[0].split(Pattern.quote(File.separator));
			String[] name      = fileName[fileName.length - 1].split("_");
			LOGGER.info(boxCoordinate);
			LOGGER.trace("Box number {} saved to file: {}",
			             Integer.parseInt(name[name.length - 2]),
			             splitLine[0]);
			addBoxCropToZProjection(boxCoordinate, Integer.parseInt(name[name.length - 2]), Color.BLACK);
		}
		String outFileZBox = this.outputDirPath + File.separator +
		                     "zprojection" + File.separator +
		                     outputFilesPrefix + "_Zprojection.tif";
		LOGGER.info("outFileZBox: {}", outFileZBox);
		saveFile(this.zProjection, outFileZBox);
	}
	
	
	/**
	 * Save the ImagePlus Z-projection image
	 *
	 * @param imagePlusInput image to save
	 * @param pathFile       path to save the image
	 */
	public void saveFile(ImagePlus imagePlusInput, String pathFile) {
		FileSaver fileSaver = new FileSaver(imagePlusInput);
		fileSaver.saveAsTiff(pathFile);
	}

	public void saveProjectionOMERO(Client client, Long output) throws Exception {
		long datasetID;
		ProjectWrapper project = client.getProject(output);
		List<DatasetWrapper> datasets = project.getDatasets("Z-Projection");
		if (datasets.isEmpty()) datasetID = project.addDataset(client, "Z-Projection", "").getId();
		else datasetID = datasets.get(0).getId();
		String outFileZBox = this.outputDirPath + File.separator +
							"zprojection" + File.separator +
							outputFilesPrefix + "_Zprojection.tif";
		client.getDataset(datasetID).importImages(client, outFileZBox);
		File file = new File(outFileZBox);
		try {
			Files.deleteIfExists(file.toPath());
		} catch (IOException e) {
			LOGGER.error("Could not delete file: {}", outFileZBox);
		}
	}
	
	/**
	 * Method to project 3D stack to 2D images using Max method projection.
	 *
	 * @param project Raw data
	 *
	 * @return Z projection
	 */
	private ImagePlus projectionMax(ZProjector project) {
		project.setMethod(ZProjector.MAX_METHOD);
		project.doProjection();
		return project.getProjection();
	}
	
	
	/**
	 * Draw box from coordinate in the Z projection image and add the crop number.
	 *
	 * @param coordinateList List of coordinate of the current box of nucleus crop
	 * @param boxNumber      Number of the crop in the list (used in the output of nucleus crop)
	 */
	private void addBoxCropToZProjection(String coordinateList, int boxNumber, Color color) {
		String[] currentBox = coordinateList.split("\t");
		/* widthBox calculation */
		int widthBox = Math.abs(Integer.parseInt(currentBox[2])) - Math.abs(Integer.parseInt(currentBox[1]));
		/* heightBox calculation */
		int heightBox = Math.abs(Integer.parseInt(currentBox[4])) - Math.abs(Integer.parseInt(currentBox[3]));
		
		ImageProcessor ip = this.zProjection.getProcessor();
		/* Line color size parameter */
		ip.setColor(color);
		ip.setLineWidth(4);
		ip.setAntialiasedText(false);
		/* Font */
		Font font = new Font("Arial", Font.PLAIN, autocropParameters.getNumberFontSize());
		ip.setFont(font);
		/* Draw current box*/
		ip.drawRect(Integer.parseInt(currentBox[1]),
		            Integer.parseInt(currentBox[3]),
		            widthBox, heightBox);
		
		/* Calculation of the coordinate to add nuclei Number */
		int xBorder = Integer.parseInt(currentBox[1]) + font.getSize()/3;
		int yBorder = Integer.parseInt(currentBox[3]) + font.getSize();
		/* Draw the nucleus number aside the box */
		TextRoi text = new TextRoi(Integer.toString(boxNumber), xBorder, yBorder, font);
		text.drawPixels(ip);
	}
	
	
	/**
	 * Method to Contrast the images values and invert the LUT.
	 *
	 * @param contrast Double number for contrast
	 */
	private void adjustContrast(double contrast) {
		ContrastEnhancer enh = new ContrastEnhancer();
		enh.stretchHistogram(this.zProjection, contrast);
		this.zProjection.getProcessor().invertLut();
		this.zProjection.updateAndDraw();
	}
	
}
